<!DOCTYPE html>
<html>
	<head>
		<script src="js/jQuery.js"></script>
	    <script type="text/javascript"
	      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB6UoYEETdTY7HuLZbQNlFvGyqXUuPkp7E">
	    </script>
	    <!--Bootstrap core JS -->
	    <script src="static/dist/js/bootstrap.min.js"></script>
	    <!-- Bootstrap core CSS -->
	    <link href="static/dist/css/bootstrap.min.css" rel="stylesheet">
	    <link rel="stylesheet" href="speckVis.css">
	</head>

	<div id="map-canvas"></div>
	<div id="sidebar">
		<div class="lead">Speck Maps Visualization</div>
		<div class="form-group" id="locationBar">
			<label for="location">Location</label><br>
			<input type="text" class="form-control" id="location" name="location" 
				placeholder="Enter address or zip code" onkeypress="updateLocationOnEnter(event)">
			<button class="btn btn-success" onclick="updateLocation()">Go</button>
			<br><br>
			<label for="location">Channel</label>&nbsp;&nbsp;&nbsp;
			<div class="btn-group" role="group">
				<button type="button" class="btn btn-success btn-xs" id="PM 2.5" onclick="changeChannelPM2_5()">PM 2.5</button>
			</div>
			<div class="btn-group" role="group">
				<button type="button" class="btn btn-success btn-xs" id="OZONE" onclick="changeChannelOzone()">Ozone</button>
			</div>
		</div>
		<div id="colorKey">
			<img src="static/colorKey.svg">
		</div>
	</div>

	<style type="text/css">
	      html, body, #map-canvas { height: 100%; width: 100%;}
	      body { margin: 0px;}
    </style>

</html>

<script type="text/javascript">

	//Disabling .getJSON's asynchronous behavior so that variables can be
	//accessed outside the getJSON function
	$.ajaxSetup({
	   async: false
	});

	//Global variables
	var id;
	var latitude;
	var longitude;
	var userLatitude;
	var userLongitude;
	var maxTime;
	var name;
	var link;
	var feedData;
	var sensors;
	var marker2;
	var map;
	var markers = [];
	var ESDR_root = "https://esdr.cmucreatelab.org/api/v1/feeds/";
	var geocoding_root = "https://maps.googleapis.com/maps/api/geocode/json?address=";
	//Uses PM2_5 for initial channel
	var currentChannel = "PM 2.5 Value";

	//Picks up user location through HTML5 geolocation
	//Plots pollution markers on the map
	function initialize() {

		//Geolocation using HTML5
		if (navigator.geolocation) {
			navigator.geolocation.getCurrentPosition(showPosition);
		} else {
			alert("Your browser doesn't support geolocation.");
		}

		//Setting the map's center to the user's location
		function showPosition(position) {
			userLatitude = position.coords.latitude;
			userLongitude = position.coords.longitude;
			var userLocation = new google.maps.LatLng(userLatitude, userLongitude);
			map.setCenter(userLocation);

			//Gets array of nearby sensors with air quality data
			sensors = findNearbySensors(userLatitude, userLongitude);

			//If no sensors are found, notify user
			if (sensors.length == 0) {
				alert("No air quality monitoring stations in your area.")
			}

			for (i = 0; i <= Object.keys(sensors).length - 1; i++) {
				//Only place marker if all the values are not null
				if (sensors[i]["latitude"] && sensors[i]["longitude"] && sensors[i][currentChannel]) {
					var latLng = new google.maps.LatLng(sensors[i]["latitude"], sensors[i]["longitude"]);
					var marker = new google.maps.Marker({
						position: latLng,
						icon: {
					      path: google.maps.SymbolPath.CIRCLE,
					      fillOpacity: 0.9,
					      fillColor: getMarkerColor(sensors[i][currentChannel]),
					      strokeWeight: 1.5,
					      strokeColor: "#000000",
					      scale: 12,
					    },
						map: map
					});
					markers.push(marker);

					var infowindow = new google.maps.InfoWindow();
					attachInfoWindow(marker, i);

					//Creates a new info window for each event
					function attachInfoWindow(marker, i) {
						google.maps.event.addListener(marker, 'click', function() {
							var contentString = "<h2>Air Quality Summary</h2>"
												+ "<div style=\"font-size:16px; line-height: 30px\">"
												+ "<b>Station Name: </b>" + sensors[i]["name"] 
												+ "<br><b>" + currentChannel + ": </b>" + sensors[i][currentChannel]
												+ "<br><b>Quality: </b>"+ getMarkerStatus(sensors[i][currentChannel])
												+ "</div>";
							infowindow.setOptions({
								content: contentString,
							});
							infowindow.open(marker.get('map'), marker);
						});
					}
				}
			}

			//Placing user's current location marker on the map
			marker2 = new google.maps.Marker({
				position: userLocation,
				icon: {
			      path: google.maps.SymbolPath.CIRCLE,
			      fillOpacity: 0.9,
			      fillColor: markerColors.userLocation,
			      strokeWeight: 1.5,
			      strokeColor: "#000000",
			      scale: 12,
			    },
				map: map
			});

			//Info window that displays user location window
			var infowindow2 = new google.maps.InfoWindow({
			      content: "<h4>Current Location</h4>"
			});

			//Opens info window on click
			google.maps.event.addListener(marker2, 'click', function() {
			    infowindow2.open(map,marker2);
			});
		}
		var mapOptions = {
		  zoom: 9,
		  mapTypeControl: false,
		};
		map = new google.maps.Map(document.getElementById('map-canvas'),
				    mapOptions);

	}
	google.maps.event.addDomListener(window, 'load', initialize);

	//Colors of the air quality levels
	var markerColors = {
		good: "#199A51",
		moderate: "#92CA61",
		unhealthy_for_sensitive_groups: "#D8E58D",
		unhealthy: "#FCE08A",
		very_unhealthy: "#F68C5B",
		hazardous: "#D93027",
		userLocation: "#4BB2FE",
		none: "#dddddd"
	};

	//Directs the request to get the marker status to the 
	//appropriate function (PM 2.5 or Ozone)
	function getMarkerStatus(value) {
		if (currentChannel == "PM 2.5 Value") {
			return getMarkerStatusPM2_5(value);
		} else if (currentChannel == "Ozone Value") {
			return getMarkerStatusOZONE(value);
		}
	}

	//Directs the request to get the marker color to the 
	//appropriate function (PM 2.5 or Ozone)
	function getMarkerColor(value) {
		if (currentChannel == "PM 2.5 Value") {
			return getMarkerColorPM2_5(value);
		} else if (currentChannel == "Ozone Value") {
			return getMarkerColorOZONE(value);
		}
	}

	//Assigns PM 2.5 classifications taken from
	//http://airnow.gov/index.cfm?action=aqibasics.aqi
	function getMarkerStatusPM2_5(value) {
		if (value <= 12) {
			return "Good";
		} else if (value <= 35.4) {
			return "Moderate";
		} else if (value <= 55.4) {
			return "Unhealthy for Sensitive Groups";
		} else if (value <= 150.4) {
			return "Unhealthy";
		} else if (value <= 250.4) {
			return "Very Unhealthy";
		} else if (value <= 500.4) {
			return "Hazardous";
		} else {
			return "None";
		}
	} 

	//Assigns PM 2.5 color codes taken from
	//http://airnow.gov/index.cfm?action=aqibasics.aqi
	function getMarkerColorPM2_5(value) {
		if (value <= 12) {
			return markerColors.good;
		} else if (value <= 35.4) {
			return markerColors.moderate;
		} else if (value <= 55.4) {
			return markerColors.unhealthy_for_sensitive_groups;
		} else if (value <= 150.4) {
			return markerColors.unhealthy;
		} else if (value <= 250.4) {
			return markerColors.very_unhealthy;
		} else if (value <= 500.4) {
			return markerColors.hazardous;
		} else {
			return markerColors.none;
		}
	}

	//Assigns Ozone classifications taken from
	//http://airnow.gov/index.cfm?action=aqibasics.aqi
	function getMarkerStatusOZONE(value) {
		if (value <= 59) {
			return "Good";
		} else if (value <= 75) {
			return "Moderate";
		} else if (value <= 95) {
			return "Unhealthy for Sensitive Groups";
		} else if (value <= 115) {
			return "Unhealthy";
		} else if (value <= 374) {
			return "Very Unhealthy";
		} else {
			return "None";
		}
	}

	//Assigns Ozone color codes taken from
	//http://airnow.gov/index.cfm?action=aqibasics.aqi
	function getMarkerColorOZONE(value) {
		if (value <= 59) {
			return markerColors.good;
		} else if (value <= 75) {
			return markerColors.moderate;
		} else if (value <= 95) {
			return markerColors.unhealthy_for_sensitive_groups;
		} else if (value <= 115) {
			return markerColors.unhealthy;
		} else if (value <= 374) {
			return markerColors.very_unhealthy;
		} else {
			return markerColors.none;
		}
	}

	//Use haversine formula to calculate new lat-long coordinates
	function haversineNewCoords(lat1, long1, distance, bearing) {
		//Converting the inputs to radians for use in the Haversine formula
		//Converting distances from km to meters
		var lat1 = lat1 * (Math.PI / 180);
		var long1 = long1 * (Math.PI / 180);
		var bearing = bearing * (Math.PI / 180);
		var distance = distance * 1000
		var earthRadius = 6371000

		//Haversine formula calculations
		//Taken from: http://www.movable-type.co.uk/scripts/latlong.html
		var newlat = (Math.asin(Math.sin(lat1)*Math.cos(distance/earthRadius) 
						+ Math.cos(lat1)*Math.sin(distance/earthRadius)*Math.cos(bearing))) * (180 / Math.PI);
		
		var newlong = (long1 + Math.atan2(Math.sin(bearing)*Math.sin(distance/earthRadius)*Math.cos(lat1),
                         Math.cos(distance/earthRadius)-Math.sin(lat1)*Math.sin(newlat))) * (180 / Math.PI);

		var coords = [newlat, newlong];
		return coords;
	}

	function getPollutantValue(link, maxTime, pollutant) {
		//Gets the last recorded pollutant reading from the sensor

		var channelLink = link + "/channels/" + pollutant + "/export?from=" + maxTime + "&to=" + maxTime;

		//Gets csv text from ESDR
	    $.ajax({
	        type: "GET",
	        url: channelLink,
	        dataType: "text",
	        success: function(data) {processData(data);}
	     });

	    //Parse the last PM2_5 value from the csv file 
		function processData(allText) {
		    var allTextLines = allText.split(/\r\n|\n/);
		    var lastLine = allTextLines[allTextLines.length-2];
		    var lastValue = lastLine.split(',')
		    pollutantValue = Number(lastValue[1]);
		}

		return pollutantValue;
	}

	//Add nearby sensors to the sensor array
	//Creates an array of objects that represents feeds 
	//within 100 square km of userlocation
	function findNearbySensors(userLatitude, userLongitude) {
		//Distance in kilometers (preset to 50km)
		var distance = 100;
		var sensors = [];

		//Create a rectangular grid to constrain the feeds using 
		//Haversine formula

		//-------------------------* (maxLatitude, maxLongitude)
		//|                        |
		//|                        |
		//|          user          |							
		//|                        |
		//|                        |
		//|________________________|
		//*
		// (minLatitude, minLongitude)

		//Bottom-left corner of the rectangle grid
		var minLatitude = haversineNewCoords(userLatitude, userLongitude, distance, 225)[0];
		var minLongitude = haversineNewCoords(userLatitude, userLongitude, distance, 225)[1];

		//Top-right corner of the rectangle grid
		var maxLatitude = haversineNewCoords(userLatitude, userLongitude, distance, 45)[0];
		var maxLongitude = haversineNewCoords(userLatitude, userLongitude, distance, 45)[1];

		var constrainedFeedLink = ESDR_root + "?where=latitude>" + minLatitude + ",latitude<" + maxLatitude 
									+ ",longitude>" + minLongitude + ",longitude<" + maxLongitude
									+ "&fields=id,latitude,longitude,maxTimeSecs,name,channelBounds";

		//Goes through each feed in the constrained link
		//Gets the latitude, longitude, pollutant value of the sensors
		//Returns a final sensor array containing air quality data from nearby sensors
		$.getJSON(constrainedFeedLink, function(json) {
			var length = json["data"]["rows"].length;

			for (k = 0; k < length; k++) {
				id = json["data"]["rows"][k]["id"];
				name = json["data"]["rows"][k]["name"];
				latitude = json["data"]["rows"][k]["latitude"];
				longitude = json["data"]["rows"][k]["longitude"];
				maxTime = json["data"]["rows"][k]["maxTimeSecs"];

				link = ESDR_root + id;

				if (currentChannel == "PM 2.5 Value") {

					//Only fetches data if pollutant feed is available, makes
					//the program a lot more efficient
					if ((json["data"]["rows"][k]["channelBounds"]) &&
						(json["data"]["rows"][k]["channelBounds"]["channels"]["PM2_5"])) {

						feedData = {
							"name": name,
							"latitude": latitude,
							"longitude": longitude,
							"PM 2.5 Value": getPollutantValue(link, maxTime, "PM2_5")
						};

						sensors.push(feedData);
					}
				} else if (currentChannel == "Ozone Value") {

					if ((json["data"]["rows"][k]["channelBounds"]) &&
						(json["data"]["rows"][k]["channelBounds"]["channels"]["OZONE"])) {

						feedData = {
							"name": name,
							"latitude": latitude,
							"longitude": longitude,
							"Ozone Value": getPollutantValue(link, maxTime, "OZONE")
						};

						sensors.push(feedData);
					}
				}
			}
		});

		return sensors;
	}

	function updateLocationOnEnter(event) {
		if (event.keyCode == 13 || event.which == 13) {
			updateLocation();
		}
	}

	//Updates the current location and finds new nearby markers when user
	//enters a new address (using Google Maps geocoding)
	function updateLocation() {
		//Fetching the address input
		var newAddress = document.getElementById("location").value;
		document.getElementById("location").placeholder = newAddress;
		var geocoding_url = geocoding_root + newAddress;

		if (newAddress != "") {

			//Identifying the lat/long of the new address using server-side geocoding
			//Read details here: https://developers.google.com/maps/articles/geocodestrat
			$.getJSON(geocoding_url, function(geocode) {

				//If the location is not recognized, alert user and return
				if (!geocode["results"][0]) {
					alert("Location not recognized. Please try again.");
					return;
				}
				var newLatitude = geocode["results"][0]["geometry"]["location"]["lat"];
				var newLongitude = geocode["results"][0]["geometry"]["location"]["lng"];
				userLatitude = newLatitude;
				userLongitude = newLongitude;
			});
		}

		var userLocation = new google.maps.LatLng(userLatitude, userLongitude);
		map.setCenter(userLocation);
		marker2.setPosition(userLocation);

		setAllMap(null);
		markers = [];

		function setAllMap(map) {
		    for (var i = 0; i < markers.length; i++) {
		        markers[i].setMap(map);
		    }
		}

		//Gets array of nearby sensors with air quality data
		sensors = findNearbySensors(userLatitude, userLongitude);
		if (sensors.length == 0) {
			alert("No air quality monitoring stations in this area.")
		}

		for (i = 0; i <= Object.keys(sensors).length - 1; i++) {
			//Only place marker if all the values are not null
			if (sensors[i]["latitude"] && sensors[i]["longitude"] && sensors[i][currentChannel]) {
				var latLng = new google.maps.LatLng(sensors[i]["latitude"], sensors[i]["longitude"]);
				var marker = new google.maps.Marker({
					position: latLng,
					icon: {
				      path: google.maps.SymbolPath.CIRCLE,
				      fillOpacity: 0.9,
				      fillColor: getMarkerColor(sensors[i][currentChannel]),
				      strokeWeight: 1.5,
				      strokeColor: "#000000",
				      scale: 12,
				    },
					map: map
				});
				markers.push(marker);

				var infowindow = new google.maps.InfoWindow();
				attachInfoWindow(marker, i);

				//Creates a new info window for each event
				function attachInfoWindow(marker, i) {
					google.maps.event.addListener(marker, 'click', function() {
						var contentString = "<h2>Air Quality Summary</h2>"
											+ "<div style=\"font-size:16px; line-height: 30px\">"
											+ "<b>Station Name: </b>" + sensors[i]["name"] 
											+ "<br><b>" + currentChannel + ": </b>" + sensors[i][currentChannel]
											+ "<br><b>Quality: </b>"+ getMarkerStatus(sensors[i][currentChannel])
											+ "</div>";
						infowindow.setOptions({
							content: contentString,
						});
						infowindow.open(marker.get('map'), marker);
					});
				}
			}
		}

		map.setOptions({
		  zoom: 9
		});
	}

	function changeChannelPM2_5() {
		document.getElementById("OZONE").style.color = "#000";
		document.getElementById("OZONE").style.background = "#fff";
		document.getElementById("OZONE").style.borderColor = "#4cae4c";
		document.getElementById("PM 2.5").style.color = "#fff";
		document.getElementById("PM 2.5").style.background = "#4cae4c";
		document.getElementById("PM 2.5").style.borderColor = "#4cae4c";
		currentChannel = "PM 2.5 Value";
		updateLocation();
	}

	function changeChannelOzone() {
		document.getElementById("PM 2.5").style.color = "#000";
		document.getElementById("PM 2.5").style.background = "#fff";
		document.getElementById("OZONE").style.color = "#fff";
		document.getElementById("OZONE").style.background = "#4cae4c";
		document.getElementById("OZONE").style.borderColor = "#4cae4c";
		currentChannel = "Ozone Value";
		updateLocation();
	}

</script>